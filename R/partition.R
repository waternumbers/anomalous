## set up generic methods
#' Method for extracting collective anomalies
#'
#' @description Extracts the collective anomaly summaries from the object
#'
#' @param p object, such as a partition, from which to extract the point anomalies
#' @param t the end time at which the partition is based
#' @export
collective_anomalies <- function(p,t){ UseMethod("collective_anomalies",p) }


#' Method for extracting point anomalies
#'
#' @description Extracts the point anomaly summaries from the object
#'
#' @param p object, such as a partition, from which to extract the point anomalies
#' @param t the end time at which the partition is based
#' @export
point_anomalies <- function(p,t){ UseMethod("point_anomalies",p) }

#' Partion record for the data
#'
#' @description A partition records the seperation of the data generated by the pelt or capa methods
#'
#' @param beta penalty for a new collective anomaly
#' @param betaP penalty for a new point anomaly
#' @param min_length shortest length of a collective anomaly
#'
#' @examples
#' p <- partition(3,4,2)
#' @export
partition <- function(beta,betaP,min_length){
    structure(list(
        endPoint=NULL,
        cost=NULL,
        type=NULL,
        beta=beta,
        betaP=betaP,
        min_length=min_length),
        class="anomalous_partition")
}


#' @export
collective_anomalies.anomalous_partition <- function(p,t=NULL){
    tmp <- summary(p,t)
    tmp[tmp$type=="collective",]
}

#' @export
point_anomalies.anomalous_partition <- function(p,t=NULL){
    tmp <- summary(p,t)
    tmp$end <- NULL
    names(tmp) <- gsub("start","location",names(tmp))
    tmp[tmp$type=="point",]
}

#' Summmary method for an amomalous_partition
#'
#' @description Provides a summary of an object with class amomalous_partition
#'
#' @param object the anomalous_partition
#' @param ... optional parameters see details
#'
#' @return A data.frame summarising the partitions
#'
#' @details If providing \code{t} a time the results prodiced are as though the analysis was stopped then.
#' @export
summary.anomalous_partition <- function(object,...){

    t <- list(...)$t
    if( is.null(t) ){ t <- tail(which(!is.na(object$cost)), 1) } ## length(object$endPoint) }
    if( length(t) == 0 ){
        return( data.frame(start = integer(0),
                           end = integer(0),
                           type = character(0),
                           cost = numeric(0) ) )
    }
    
    tmp <- t
    while(tmp[1] > 0){ tmp <- c( object$endPoint[tmp[1]], tmp) }
    
    data.frame(start = head(tmp+1, -1),
               end = tmp[-1],
               type = object$type[ tmp[-1] ],
               cost = diff( c(0,object$cost[ tmp[-1] ]) )
               )
}

#' Plot method for an amomalous_partition
#'
#' @description Provides a summary plot of an object with class amomalous_partition
#'
#' @param x the anomalous_partition
#' @param ... optional parameters see details
#'
#' @return Produces a plot
#'
#' @details If providing \code{t} a time the results prodiced are as though the analysis was stopped then.
#' The optional inputs \code{xx} and \code{yy} allow for data to be displayed under the shaded anomaly/changepoint areas.
#' If no data is provided \code{xx = 1:t} and \code{yy} is the cost of the periods the timestep is in.
#' @export
plot.anomalous_partition <- function(x,...){

    eli <- list(...)
    showRegions <- ifelse(is.null(eli$showRegions[1]),TRUE,as.logical(eli$showRegions[1]))

    if("t" %in% names(eli)){
        t <- eli$t
        sm <- summary(x,t)
    }else{
        sm <- summary(x)
        t <- tail(sm$end,1)
    }

    if("xx" %in% names(eli)){
        eli$x <- eli$xx[1:t]
        eli$xx <- NULL
    }else{
        eli$x <- 1:t
    }
                                                
    if( "yy" %in% names(eli) ){
        eli$y <- eli$yy[1:t]
        eli$yy <- NULL
    }else{
        ## fill eli$y with costs
        eli$y <- rep(NA,t)
        for(ii in 1:nrow(sm)){
            eli$y[ sm$start[ii]:sm$end[ii] ] <- sm$cost[ii] / (sm$end[ii]-sm$start[ii]+1)
        }
        eli$ylab = "Cost per observation"
    }
    
    if(!("xlab" %in% names(eli))){eli$xlab=""}
    if(!("ylab" %in% names(eli))){eli$ylab=""}

    eli$t <- NULL
    if( is.matrix(eli$y) ){
        eli$type="l"
        do.call(matplot,eli)
    }else{
        do.call(plot,eli)
    }
    
    if(showRegions){
        for(ii in which(sm$type=="collective")){
            graphics::rect(xleft = eli$x[ sm$start[ii] ],
                           xright = eli$x[ sm$end[ii] ],
                           ybottom = graphics::par("usr")[3],
                           ytop = graphics::par("usr")[4], 
                           border = NA,
                           col = grDevices::adjustcolor("blue", alpha = 0.3))
        }
        idx <- sm$start[ which(sm$type=="point") ]
        graphics::points( eli$x[idx], eli$y[idx], pch=23,
                         col = "red" )
    }
}

#' Coefficent method for an amomalous_partition
#'
#' @description Generates coefficents for the anomalous periods in an object with class amomalous_partition
#'
#' @param object the anomalous_partition
#' @param ... optional parameters see details
#'
#' @return A matrix of parameters whose rows correspond to the rows in the summary output
#' 
#' @details Generates coefficents for all anomalous periods. Required input \code{cost} is a cost function. Optional input \code{t} is the time of the partitioning solution to use.
#' @export
coef.anomalous_partition <- function(object,...){

    eli <- list(...)
    if("t" %in% names(eli)){
        t <- eli$t
        sm <- summary(object,t)
    }else{
        sm <- summary(object)
        t <- tail(sm$end,1)
    }
    fCost <- eli$cost
    if(is.null(fCost)){ stop("A cost function is required") }
    if( !("param" %in%  names(fCost)) ){ stop("Parameter method not available for cost function") }

    tmp <- fCost$param(sm$start[1],sm$end[1])
    out <- matrix(NA,nrow(sm),length(tmp),dimnames=list(NULL,names(tmp)))
    
    for(ii in 1:nrow(sm)){
        if( sm$type[ii] %in% c("collective","point") ){
            out[ii,] <- fCost$param(sm$start[ii],sm$end[ii]) #,sm$type[ii])
        }
    }
    return(out)
}
