
## ####################################################################################
## gauss mean
#' @include generics.R
#' @include segment.R
setClass("gaussMean",contains = "Segment",
         prototype = list(
             summaryStats = c(sum_w=0,
                              sum_log_sig=0,
                              sum_eta=0,
                              sum_eta2=0),
             param = c(m = NA_real_, s = NA_real_)
         ))


#' meanSegment
#' @param pen Penalisation term for the segment
#' 
#' @export
gaussMean <- function(beta,t){
    out <- new("gaussMean", start=as.integer(t), penalty=beta)
    return( out )
}

#' @rdname update-methods
setMethod("update","gaussMean",
          function(obj,x,mu,sigma){
              obj@n <- obj@n + as.integer(1)
              ## ss <- obj@summaryStats
              ## ss <- ss + c(1/sigma,log(sigma),(x-mu)/sigma,((x-mu)^2)/sigma)
              ## obj@summaryStats <- ss
              ## obj@param["m"] <- ss["sum_eta"] / ss["sum_w"]
              
              ## kappa <- ( ss["sum_eta2"] - 2*obj@param["m"]*ss["sum_eta"] +
              ##            (obj@param["m"]^2)*ss["sum_w"]) / obj@n

              obj@summaryStats <- obj@summaryStats + c(1/sigma,log(sigma),(x-mu)/sigma,((x-mu)^2)/sigma)
              obj@param["m"] <- obj@summaryStats["sum_eta"] /obj@summaryStats["sum_w"]
              kappa <- ( obj@summaryStats["sum_eta2"] - 2*obj@param["m"]*obj@summaryStats["sum_eta"] +
                         (obj@param["m"]^2)*obj@summaryStats["sum_w"]) / obj@n
              obj@param["s"] <- 1
              
              obj@cost <- as.numeric(obj@n*log(2*pi*obj@param["s"]) +
                  obj@summaryStats["sum_log_sig"] + (1/obj@param["s"])*obj@n*kappa) + obj@penalty

              return(obj)
          }
          )

## ####################################################################################
## gauss variance
#' @include generics.R
setClass("gaussVar",contains = "Segment",
         prototype = list(
             summaryStats = c(sum_w=0,
                              sum_log_sig=0,
                              sum_eta=0,
                              sum_eta2=0),
             param = c(m = NA_real_, s = NA_real_)
         ))


#' gaussVar
#' @param pen Penalisation term for the segment
#' 
#' @export
gaussVar <- function(beta,t){
    out <- new("gaussVar", start=as.integer(t), penalty=beta)
    return( out )
}

#' @rdname update-methods
setMethod("update","gaussVar",
          function(obj,x,mu,sigma){
              obj@n <- obj@n + as.integer(1)
              ss <- obj@summaryStats
              ss <- ss + c(1/sigma,log(sigma),(x-mu)/sigma,((x-mu)^2)/sigma)
              obj@summaryStats <- ss
              obj@param["m"] <- 0
              
              kappa <- ( ss["sum_eta2"] - 2*obj@param["m"]*ss["sum_eta"] +
                         (obj@param["m"]^2)*ss["sum_w"]) / obj@n
              kappa <- max(kappa,2*.Machine$double.xmin) ## to catch when s is zero...
              obj@param["s"] <- kappa
              
              obj@cost <- as.numeric(obj@n*log(2*pi*obj@param["s"]) +
                  ss["sum_log_sig"] + (1/obj@param["s"])*obj@n*kappa) + obj@penalty

              return(obj)
          }
          )

## ####################################################################################
## gauss mean & variance
#' @include generics.R
setClass("gaussMeanVar",contains = "Segment",
         prototype = list(
             summaryStats = c(sum_w=0,
                              sum_log_sig=0,
                              sum_eta=0,
                              sum_eta2=0),
             param = c(m = NA_real_, s = NA_real_)
         ))


#' gaussMeanVar
#' @param pen Penalisation term for the segment
#' 
#' @export
gaussMeanVar <- function(beta,t){
    out <- new("gaussMeanVar", start=as.integer(t), penalty=beta)
    return( out )
}

#' @rdname update-methods
setMethod("update","gaussMeanVar",
          function(obj,x,mu,sigma){
              obj@n <- obj@n + as.integer(1)
              ss <- obj@summaryStats
              ss <- ss + c(1/sigma,log(sigma),(x-mu)/sigma,((x-mu)^2)/sigma)
              obj@summaryStats <- ss
              obj@param["m"] <- ss["sum_eta"] / ss["sum_w"]
              
              kappa <- ( ss["sum_eta2"] - 2*obj@param["m"]*ss["sum_eta"] +
                         (obj@param["m"]^2)*ss["sum_w"]) / obj@n
              kappa <- max(kappa,2*.Machine$double.xmin) ## to catch when s is zero...
              obj@param["s"] <- kappa
              
              obj@cost <- as.numeric(obj@n*log(2*pi*obj@param["s"]) +
                  ss["sum_log_sig"] + (1/obj@param["s"])*obj@n*kappa) + obj@penalty

              return(obj)
          }
          )

## ####################################################################################
## gauss fixed
#' @include generics.R
setClass("gaussFixed",contains = "Segment",
         prototype = list(
             summaryStats = c(sum_w=0,
                              sum_log_sig=0,
                              sum_eta=0,
                              sum_eta2=0),
             param = c(m = NA_real_, s = NA_real_)
         ))


#' meanSegment
#' @param pen Penalisation term for the segment
#' 
#' @export
gaussFixed <- function(beta,t){
    out <- new("gaussFixed", start=as.integer(t), penalty=beta)
    return( out )
}

#' @rdname update-methods
setMethod("update","gaussFixed",
          function(obj,x,mu,sigma){
              obj@n <- obj@n + as.integer(1)
              ss <- obj@summaryStats
              ss <- ss + c(1/sigma,log(sigma),(x-mu)/sigma,((x-mu)^2)/sigma)
              obj@summaryStats <- ss
              obj@param["m"] <- 0
              
              kappa <- ( ss["sum_eta2"] - 2*obj@param["m"]*ss["sum_eta"] +
                         (obj@param["m"]^2)*ss["sum_w"]) / obj@n
              ## kappa <- max(kappa,2*.Machine$double.xmin) ## to catch when s is zero...
              obj@param["s"] <- 1
              obj@cost <- as.numeric(obj@n*log(2*pi*obj@param["s"]) +
                  ss["sum_log_sig"] + (1/obj@param["s"])*obj@n*kappa) + obj@penalty

              return(obj)
          }
          )

## ###################################################################################
#' @include generics.R
setClass("gaussPoint",contains = "Segment",
         prototype = list(
             summaryStats = c(sum_w=0,
                              sum_log_sig=0,
                              sum_eta=0,
                              sum_eta2=0),
             param = c(m = NA_real_, s = NA_real_)
         ))
#' gaussPoint
#' @param pen Penalisation term for the segment
#' 
#' @export
gaussPoint <- function(beta,t){
    out <- new("gaussPoint", start=as.integer(t), penalty=beta)
    return( out )
}

#' @rdname update-methods
setMethod("update","gaussPoint",
          function(obj,x,mu,sigma){
              if(obj@n>0){ obj@cost <- Inf; return(obj) }
              
              obj@n <- as.integer(1)
              ss <- obj@summaryStats + c(1/sigma,log(sigma),(x-mu)/sigma,((x-mu)^2)/sigma)
              obj@summaryStats <- ss
              obj@param["m"] <- 0
              
              
              kappa <- ( ss["sum_eta2"] - 2*obj@param["m"]*ss["sum_eta"] +
                         (obj@param["m"]^2)*ss["sum_w"]) / obj@n
              ## kappa <- max(kappa,2*.Machine$double.xmin) ## to catch when s is zero...
              obj@param["s"] <- kappa
              
              obj@cost <- as.numeric(
                  log(2*pi) + log(sigma) + log( exp(-obj@penalty) + kappa ) + 1 + obj@penalty )

              return(obj)
          }
          )
